;***********************************************************************************
;		  	  ПРОГРАММА ШИФРОВАНИЯ ЦЕЗАРЕМ
;***********************************************************************************
;-----------------------------------------------------------------------------------
;----------------------ОБЪЯВЛЕНИЕ ИМЕН ПОРТОВ И ИХ БИТОВ----------------------------
;-----------------------------------------------------------------------------------

;----------------------------ОБЪЯВЛЕНИЕ КОНСТАНТ------------------------------------
NRK		Equ 2		;кол-во строк клавиатуры
NCK		Equ 4		;кол-во колонок клавиатуры
NKey		Equ NRK*NCK	;кол-во кнопок клавиатуры
NR		EQU 4		;кол-во строк дислея
NC	  	EQU 16		;кол-во колонок дисплея
NS	  	EQU NR*NC	;число символов дисплея
N		EQU 91		;число символов алфавита в таблице кодировки

;---------------------ОБЪЯВЛЕНИЕ ИМЕН ПОРТОВ И ИХ БИТОВ-----------------------------
KEYPORT		EQU P1		;порт приема кнопок клавиатуры
DPORT		EQU P2		;порт выдачи данных на дисплей
CPORT		EQU P0		;порт управления
RS		EQU DPORT.2	
E		EQU DPORT.3


;-----------------------ОБЪЯВЛЕНИЕ АДРЕСОВ ПЕРЕМЕННЫХ-------------------------------
X		Equ 24
X1		Equ 25
Y		Equ 26
CTR		Equ 27
CTC		Equ 28
MSK		Equ 29
FL		Equ 32
Key 		Equ 33
CTS		EQU 30		;номер символа отображаемого на дисплее
COM		EQU 31		;команда дисплея
NTEXT		EQU 35		;счетчик номера символа текстового буфера
KKey		EQU 40		;ключ шифрования
ATEXT		EQU 41		;начальный адрес текстового буфера


;------------------------------НАЧАЛО ПРОГРАММЫ-------------------------------------

;---------------------------СБРОС МИКРОКОНТРОЛЛЕРА----------------------------------
Org 0
JMP Init

;--------------------------В-р прерывания таймера Т0--------------------------------
Org 0Bh
JMP Int_opros

;------------------------ИНИЦИАЛИЗАЦИЯ МИКРОКОНТРОЛЛЕРА-----------------------------
Init:
MOV KEYPORT,#0FFh
MOV DPORT,#0
MOV FL,#0			;Обнулить флаг клавиатуры
MOV X,#0			;Обнулить текущий код клавиатуры
MOV X1,#0			;Обнулить предыдущий код клавиатуры
MOV Y,#0			;Обнулить выходной код клавиатуры
CALL INIT_LCD			;инициализация дисплея
CALL CLEARBUF			;очистка текстового буфера
CALL Timer0_Init		;Настроить таймер Т0
	
;-----------------------------ОСНОВНАЯ ПРОГРАММА------------------------------------
Begin:
CALL FLK1
CALL FLK2
CALL FLK3
CALL KEY_FORM
CALL KEY_TEST

SJMP Begin

;----------Подпрограмма настройки таймера Т0 на 30мс режим работы-------------------
Timer0_Init:			
MOV TMOD,#00000001b		;Установка режима 1 таймера Т0
MOV TH0, #HIGH(-30000)		;Загрузить старший байт таймера
MOV TL0, #LOW(-30000)		;Загрузить младший байт таймера
ORL IE,#10000010b		;Разрешить прерывания от таймера
SETB TR0			;Включить таймер
RET				;и вернуться в основную программу

;-----------Подпрограмма прерывания на опрос и анализ клавиатуры--------------------
Int_opros:
MOV TH0, #HIGH(-30000)		;Загрузить старший байт таймера
MOV TL0, #LOW(-30000)		;Загрузить младший байт таймера
PUSH ACC			;Сохранить в стеке аккумулятор
PUSH PSW			;Сохранить в стеке слово состояний
CALL Opros_Key			;Опросить клавиатуру
CALL Analiz_Key			;проанализировать код клавиатуры
POP PSW				;Считать из стека слово состояний
POP ACC				;Считать из стека аккумулятор
RETI				;Возврат из подпрограммы прерывания

;-------------------Подпрограмма опроса состояния кнопок----------------------------
Opros_Key:
MOV A, P1			;Чтение состояния кнопок
MOV X, #0			;Х=0
Next_opros:			;Начало опроса ряда кнопок
INC X				;Инкремент счетчика состояния кнопок
MOV R2, X				
CJNE R2, #(NKey+1), Shift
MOV X, #0
JMP Opros_end
Shift:				;Проверка нажатия кнопки
RRC A
JC Next_opros			;Завершение проверки, если кнопка нажата
Opros_end:
RET

;--------------------Подпрограмма анализа кодов клавиатуры--------------------------
Analiz_Key:
MOV A, X			;Проверка Х=Х1, и, если нет, то переход к Set_X1,
CJNE A, X1, Set_X1		;иначе:
CJNE A, Y, Set_Y		;Проверка Y=X, и, если нет, то переход к Set_Y,
JMP End_analis			;иначе завершение анализа
Set_X1:
MOV X1, A			;Х1=Х
JMP End_analis
Set_Y:
MOV R2, Y			;Проверка Y=0 и если нет, то переход к CLR_FL,
CJNE R2, #0, CLR_FL		;иначе:
MOV Y, A			;Y=X
MOV FL, #1			;установка флага FL=1
JMP End_analis
CLR_FL:
MOV Y, A			;Y=X
MOV FL, #0			;FL=0
End_analis:
RET				;Возврат из подпрограммы
	
;---------------------Подпрограмма инициализации дисплея----------------------------
INIT_LCD:
	CALL DELAY_40ms
	MOV DPORT, #00101011b
	CLR E
	CALL DELAY_43us
	MOV COM, #00101000b
	CALL WRITE_COM
	CALL WRITE_COM
	MOV COM, #00001110b
	CALL WRITE_COM
	MOV COM, #00000110b
	CALL WRITE_COM
	CALL CLEAR_LCD
	RET

;--------------------Подпрограмма записи команды в дисплей--------------------------
WRITE_COM:
	MOV A, COM
	ORL A, #00001111b
	ANL A, #11111001b
	MOV DPORT, A
	CLR E
	MOV A, COM
	SWAP A
	ORL A, #00001111b
	ANL A, #11111001b
	MOV DPORT, A
	CLR E
	CALL DELAY_43us
	RET

;------------------Подпрограмма ожидания готовности дисплея--------------------------
WAIT_BF:
MOV DPORT,#0FFh
CLR RS
	
;---------------------Подпрограмма очистки экрана дисплея----------------------------
CLEAR_LCD:
	MOV COM, #00000001b
	CALL WRITE_COM
	MOV CTS, #0
	;MOV ADR, #0
	CALL ADDR_SET
	RET

;--------------------Подпрограмма установки адреса дисплея---------------------------
ADDR_SET:
	ORL A, #10000000b
	MOV COM, A
	CALL WRITE_COM
	RET

;--------------------Подпрограмма выдачи символов на дисплей-------------------------
WRITE_SYMB:
CALL ADDR_CALC
	CALL ADDR_SET
	MOV A, Key
	ADD A,#20h
	ORL A, #00001111b
	ANL A, #11111101b
	MOV DPORT, A
	CLR E
	MOV A, Key
	ADD A,#20h
	SWAP A
	ORL A, #00001111b
	ANL A, #11111101b
	MOV DPORT, A
	CLR E
	CALL DELAY_43us
	INC CTS
	
	CALL ADDR_CALC
	CJNE A,#64+2*NC,WRITE_END
	DEC A
	WRITE_END:
	CALL ADDR_SET
	RET

;------------------Подпрограмма вычисления адреса памяти дисплея---------------------
;----------------------------(для дисплея на 4 строки)-------------------------------
ADDR_CALC:
	MOV A, CTS
	CLR C
	SUBB A, #NC
	JC ROW1
	SUBB A, #NC
	JC ROW2
	SUBB A, #NC
	JC ROW3
	SUBB A, #NC
	JC ROW4
	SUBB A, #NC
	MOV A, #64+2*NC-NS
	JMP ADDCTS

	ROW1:
	MOV A, #0
	JMP ADDCTS
	
	ROW2:
	MOV A, #64-NC
	JMP ADDCTS
	
	ROW3:
	MOV A, #256-NC
	JMP ADDCTS
	RET
	
	ROW4:
	MOV A, #64-2*NC

	
	ADDCTS:
	ADD A, CTS
	RET
;-------------------------Подпрограмма задержки на 43 мкс----------------------------
DELAY_43us:
	MOV R5, #20
LABEL1:
	DJNZ R5, LABEL1
        RET

;-------------------------Подпрограмма задержки на 1,53 мс---------------------------
DELAY_1530us:
	MOV R6, #35
LABEL2:
	CALL DELAY_43us
	DJNZ R6, LABEL2
	RET
	
;--------------------------Подпрограмма задержки на 40 мс----------------------------
DELAY_40ms:
	MOV R7, #26
LABEL3:
	CALL DELAY_1530us
	DJNZ R7, LABEL3
	RET

;-------------------------Ввод кода первой нажатой клавиши---------------------------
FLK1:
CALL FLK_TEST
MOV R3, A
MOV COM, #00001100b
CALL WRITE_COM
RET

;-------------------------Ввод кода второй нажатой клавиши---------------------------
FLK2:
CALL FLK_TEST
MOV R4, A
MOV COM, #00001111b
CALL WRITE_COM
RET

;-------------------------Ввод кода третьей нажатой клавиши---------------------------
FLK3:
CALL FLK_TEST
MOV R7, A
MOV COM, #00001110b
CALL WRITE_COM
RET

;--------------------Подпрограмма проверки факта нажатия клавиши---------------------
FLK_TEST:
MOV A, FL
CJNE A, #1, FLK_TEST
MOV FL, #0
MOV A, Y

DEC A
RET

;---------------------Подпрограмма формирования кода клавиатуры----------------------
KEY_FORM:
MOV A, R3
MOV B, #NKey
MUL AB
ADD A, R4
MOV B, #NKey
MUL AB
ADD A, R7
MOV Key, A
RET

;-----------Подпрограмма дешифрования кода клавиатуры и выполнения команд------------
KEY_TEST:			;Проверка символ или команда
MOV A, Key
CLR C
SUBB A, #05Bh
JNC COMAND_TEST
;----------------------Запись символа в буфер и вывода на экран----------------------
CALL WRITE_BUF
CALL WRITE_SYMB			;выдача символа на дисплей
JMP END_TEST			;завершение тестирования кодов клавиатуры

;-------------------Проверка и отработка кодов команд клавиатуры---------------------
COMAND_TEST:
MOV A, Key

;-------------------Проверка и выполнение команды очистка экрана---------------------
TEST91:
CJNE A, #05Bh, TEST92		;проверка Кеу=5Bh, если нет, то переход к
				;проверке следующей команды, если да, то
CALL CLEARBUF			
CALL CLEAR_LCD			;очистка экрана дисплея
JMP END_TEST			;завершение тестирования кодов клавиатуры

;---------------------Проверка и выполнение команды забой (134)----------------------
TEST92:
CJNE A, #5CH, TEST93		;проверка Кеу=5СН, если нет, то завершение
				;если да, то выполнение команы Забой (слева):
MOV R1, CTS			;загрузка позиции курсора
CJNE R1, #0, zab		;если нулевая позиция, то забой
JMP END_TEST			;если нулевая, то завершение без забоя

zab:				;выполнение забоя
DEC CTS				;декремент позиции курсора
MOV Key, #0			;выдача кода пробела на дисплей
CALL WRITE_BUF			
CALL WRITE_SYMB			;(очистка позиции)
DEC CTS				;декремент позиции курсора
CALL ADDR_CALC			;вычисление позиции курсора
CALL ADDR_SET			;установка адреса курсора
CALL END_TEST			;завершение тестирования кодов клавиатуры
END_TEST:
RET

;--------Проверка и отработка команды "Ввод ключа" (код 135)--------
;------------------(первый символ верхней строки)-------------------
TEST93: CJNE A, #93, TEST94
MOV A, ATEXT		;чтение первого символа текста
MOV KKey, ACC		;сохранение ключа
RET

;-----Проверка и отработка команды. Зашифровать текст (код 136)-----
TEST94: CJNE A, #94, TEST95
MOV A, CTS		;чтение числа введеных символов
MOV R1, A		;сохранение числа символов
MOV CTS, #0		;обнуление счетчика символов
MOV A, #0
CALL ADDR_SET		;Установка ареса (курсора) в нулевую позицию
MOV R0, #ATEXT		;установка указателя косвенного адреса в начало
Read_x:
MOV A, @R0		;чтение символа открытого текста
ADD A, KKEY		;вычисление х+k
MOV B, #N		;загрузка n
DIV AB			;вычисление у=(x+k)mod n
MOV @R0, B		;запись у в текущую позицию строки текста
INC R0			;инкремент адреса символа текста
MOV Key, B		;установка кода символа клавиатуры
CALL WRITE_SYMB		;выдача символа на дисплей
DJNZ R1, Read_x		;декрмент счетчика символов, и если не 0, повтор
RET

;--------------------Проверка и отработка команды-----------------------
;------------------------Дешифрование текста----------------------------
TEST95: CJNE A, #95, END_TEST
MOV A, CTS		;чтение числа введенных символов
JZ END_TEST		;если 0, то завершение, иначе
MOV R1, A		;сохранение числа символов
MOV CTS, #0		;обнуление счетчика символов
MOV ACC, #0
CALL ADDR_SET		;Установка адреса (курсора) в нулевую позицию
MOV R0, #ATEXT		;установка указателя косвенного адреса в начало
Read_y:
MOV A, @R0		;чтение символа закрытого текста
ADD A, #N		;вычисление у+n
CLR C			;очистка бита переноса
SUBB A, KKEY		;вычисление y+n-k
MOV B, #N		;загрузка n
DIV AB			;вычисление х=(y+n-k)mod n
MOV @R0, B		;запись х в текущую позицию строки текста
INC R0			;инкремент адреса символа текста
MOV Key, B		;установка кода символа клавиатуры
CALL WRITE_SYMB		;выдача символа на дисплей
DJNZ R1, Read_y		;декремент счетчика символов, и если не 0, то повтор

;---------------Подпрограмма очистки текстового буфера----------------
CLEARBUF:
MOV R0, #ATEXT
MOV R2, #NS
MOV A, #0
CLRB:
MOV @R0, A
INC R0
DJNZ R2, CLRB
RET

;----------------Подпрограмма записи в текстовый буфер----------------
WRITE_BUF:
MOV R2, CTS
CJNE R2, #NS, WRB
JMP END_WR
WRB:
MOV A, #ATEXT
ADD A, R2
MOV R0, A
MOV A, KEY
MOV @R0, A
END_WR:
RET

END